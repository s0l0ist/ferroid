syntax = "proto3";

package idgen;

// ID generation service optimized for high-throughput streaming.
//
// This service enables clients to request a large number of unique identifiers
// using a stream-based interface. IDs are returned in compact, binary-packed
// format to minimize overhead and maximize throughput.
//
// Designed for use cases like event ingestion, distributed databases, or
// systems that need to preallocate batches of globally unique IDs.
service IdGen {
  // Streams back a specified number of IDs in one or more binary chunks.
  //
  // The client specifies the desired `count`, and the server responds with a
  // stream of `IdUnitResponseChunk` messages. Each chunk contains a packed byte
  // buffer of one or more serialized Snowflake-style IDs.
  //
  // IMPORTANT: The response uses a raw binary format for performance reasons.
  // It is the client's responsibility to correctly deserialize and interpret
  // the bytes according to the expected ID type.
  //
  // Typically, IDs are 64-bit unsigned integers (`u64`), but implementations
  // may support other widths, such as 128-bit (`u128`), depending on
  // configuration or crate parameters. Clients must ensure they correctly align
  // the deserialization logic (e.g., 8 bytes per `u64`, 16 bytes per `u128`).
  rpc GetStreamIds (IdStreamRequest) returns (stream IdUnitResponseChunk);
}

// Request message for streaming a batch of unique IDs.
//
// The client specifies the number of unique IDs it wishes to receive. The
// server will stream back one or more binary chunks until the requested number
// of IDs has been delivered.
message IdStreamRequest {
  // Total number of unique IDs to generate and return.
  uint64 count = 1;
}

// A response message containing a chunk of packed binary IDs.
//
// The `packed_ids` field is a contiguous byte array containing one or more
// serialized unique identifiers. The encoding is fixed-width and little-endian.
//
// Clients must read the bytes according to the Snowflake ID's underlying type:
// - If `u64`, read in 8-byte chunks: `u64::from_le_bytes([u8; 8])`
// - If `u128`, read in 16-byte chunks: `u128::from_le_bytes([u8; 16])`
//
// Invariants:
// - `packed_ids.length % ID_SIZE == 0`
// - Each fixed-size chunk represents one unique ID
message IdUnitResponseChunk {
  // Packed binary IDs, encoded as fixed-width little-endian values.
  //
  // The server does not specify the ID size â€” clients must decode it
  // consistently with the agreed-upon ID type (typically 8 or 16 bytes).
  bytes packed_ids = 1;
}
